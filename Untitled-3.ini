# ===================================================================
# AI 토마토 자동 수확 로봇 시스템 - 연속 작업 및 양방향 통신 버전
# ===================================================================
# - 아두이노가 "Check" 신호를 보내야만 카메라 스캔을 시작합니다.
# - 아두이노가 "End" 신호를 보내면 프로그램이 안전하게 종료됩니다.
# - 스캔 후 토마토가 없으면 아두이노에 "None" 신호를 보냅니다.
# - 전체 로직을 아두이노의 요청에 응답하는 방식으로 변경했습니다.
# ===================================================================

import torch
import cv2
import serial
import time
import os

# --- 설정 (사용자 환경에 맞게 반드시 수정해주세요!) ---
YOLO_REPO_PATH = '/home/tomato/deeplearning'
MODEL_PATH = '/home/tomato/deeplearning/yolov5/best1.pt'
CLASS_NAMES = ['unripe', 'semi-ripe', 'fully-ripe']

# 아두이노와 통신할 시리얼 포트 및 속도
SERIAL_PORT = '/dev/ttyACM0'
BAUD_RATE = 115200

# --- 고급 설정 ---
CAM_INDEX = 0
CONF_THRESHOLD = 0.9
IOU_THRESHOLD = 0.4
RESULT_IMAGE_PATH = "detection_result.png"

# 시리얼 통신 신호 정의
ARDUINO_CHECK_SIGNAL = "Check" # 아두이노가 스캔을 요청할 때 보내는 신호
ARDUINO_END_SIGNAL = "End"     # 아두이노가 (라인이 없을 때)모든 작업을 끝낼 때 보내는 신호
NO_TOMATO_SIGNAL = "None"      # 탐지된 토마토가 없을 때 파이썬이 보내는 신호

# -------------------------------------------------------------------

def load_yolo_model():
    """로컬 YOLOv5 저장소를 사용하여 모델을 로드합니다."""
    print("YOLOv5 모델을 로드하는 중입니다...")
    if not os.path.exists(YOLO_REPO_PATH) or not os.path.exists(MODEL_PATH):
        print(f"오류: YOLOv5 폴더('{YOLO_REPO_PATH}') 또는 모델 파일('{MODEL_PATH}')을 찾을 수 없습니다.")
        return None
    try:
        model = torch.hub.load(YOLO_REPO_PATH, 'custom', path=MODEL_PATH, source='local')
        model.conf = CONF_THRESHOLD
        model.iou = IOU_THRESHOLD
        print("모델 로드 완료.")
        return model
    except Exception as e:
        print(f"오류: YOLO 모델 로드에 실패했습니다. {e}")
        return None

#이미지 캡쳐 후 탐지
def capture_and_detect(model, cam_index):
    if model is None: return None, None
    
    cap = cv2.VideoCapture(cam_index)
    if not cap.isOpened():
        print(f"오류: 카메라(인덱스: {cam_index})를 열 수 없습니다.")
        return None, None

    for _ in range(5): cap.read()
    ret, frame = cap.read()
    cap.release()

    if not ret:
        print("오류: 카메라에서 프레임을 캡처할 수 없습니다.")
        return None, None

    print("이미지에서 객체 탐지를 수행합니다...")
    results = model(frame)
    return frame, results

# 모든 토마토의 좌표를 반환하도록 변경
def process_results(frame, results):
    detections = results.xyxy[0]
    print(f"총 {len(detections)}개의 객체를 탐지했습니다.")
    
    all_coords_to_send = []
    colors = [(0, 255, 0), (0, 255, 255), (0, 0, 255)]

    for *box, conf, cls_idx_tensor in detections:
        x1, y1, x2, y2 = map(int, box)
        cls_idx = int(cls_idx_tensor)
        
        if cls_idx >= len(CLASS_NAMES): continue
            
        xc = (x1 + x2) // 2
        yc = (y1 + y2) // 2
        class_name = CLASS_NAMES[cls_idx]
        color = colors[cls_idx]
        
        print(f"→ 탐지: {class_name} (신뢰도: {conf:.2f}), 중심: ({xc}, {yc})")
        #클래스와 상관없이 모든 토마토의 좌표를 리스트에 추가
        all_coords_to_send.append(f"{xc},{yc}")

        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
        cv2.putText(frame, f"{class_name} {conf:.2f}", (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)
        cv2.circle(frame, (xc, yc), 5, color, -1)

    cv2.imwrite(RESULT_IMAGE_PATH, frame)
    print(f"탐지 결과가 '{RESULT_IMAGE_PATH}' 파일로 저장되었습니다.")
    return all_coords_to_send #모든 좌표 리턴

#데이터(좌표 또는 신호)를 전송하는 함수
def send_data_to_arduino(data):
    """계산된 좌표 또는 제어 신호를 아두이노로 전송합니다."""
    if not data:
        print("전송할 데이터가 없습니다.")
        return

    # 데이터가 리스트(좌표)인 경우, "x1,y1/x2,y2/" 형태의 문자열로 변환
    if isinstance(data, list):
        data_str = '/'.join(data) + '/'
    # 데이터가 문자열(신호)인 경우, 그대로 사용
    else:
        data_str = str(data)

    ser = None
    try:
        print(f"아두이노({SERIAL_PORT})에 데이터 전송을 시도합니다...")
        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=2)
        time.sleep(2)
        ser.write(data_str.encode('utf-8'))
        print(f"전송한 데이터: {data_str}")
    except serial.SerialException as e:
        print(f"  시리얼 통신 오류: {e}")
    except Exception as e:
        print(f"  데이터 전송 중 예상치 못한 오류 발생: {e}")
    finally:
        if ser and ser.is_open:
            ser.close()


#아두이노로부터 신호를 수신 대기하는 함수
def wait_for_arduino_signal():
    ser = None
    try:
        print(f"\n아두이노로부터 신호 수신 대기 중...")
        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=None)
        line = ser.readline().decode('utf-8').strip()
        if line:
            print(f"'{line}' 신호를 수신했습니다.")
            return line
        return NO_TOMATO_SIGNAL # 빈 신호 수신 시
    except serial.SerialException as e:
        print(f"  시리얼 통신 오류: {e}")
        return "Error"
    except KeyboardInterrupt:
        print("사용자에 의해 프로그램이 중단되었습니다.")
        return ARDUINO_END_SIGNAL
    finally:
        if ser and ser.is_open:
            ser.close()
            print("시리얼 포트 연결을 닫았습니다.")


def main():
    """메인 실행 함수 (연속 작업 루프)"""
    print("--- 토마토 탐지 및 좌표 전송 프로그램 시작 ---")
    
    model = load_yolo_model()
    if model is None:
        return

    # 프로그램이 계속 실행되도록 무한 루프 시작
    while True:
        # 1. 이미지 캡처 및 탐지
        frame, results = capture_and_detect(model, CAM_INDEX)
        if frame is None or results is None:
            print("이미지 처리 중 오류 발생. 5초 후 재시도합니다.")
            time.sleep(5)
            continue # 루프의 처음으로 돌아감

        # 2. 결과 분석 및 모든 토마토 좌표 추출
        coords_to_send = process_results(frame, results)

        # 3. 분기 처리: 탐지된 토마토가 있는지 없는지 확인
        if coords_to_send: # 탐지된 토마토가 하나라도 있다면
            # 3-1. 아두이노로 모든 토마토 좌표 전송
            send_data_to_arduino(coords_to_send)
            
            # 3-2. 아두이노가 수확을 마치고 "Check" 신호를 보낼 때까지 대기
            if not wait_for_arduino_signal():
                break # 신호 대기 중 문제 발생 시 루프 탈출

        else: # 탐지된 토마토가 하나도 없다면 (수확 완료)
            print("\n모든 토마토가 수확된 것을 확인했습니다.")
            # 4. 아두이노에 작업 완료("None") 신호 전송
            send_data_to_arduino(END_SIGNAL)
            print("--- 모든 작업 완료 ---")
            break

if __name__ == '__main__':
    main()
